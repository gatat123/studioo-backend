# 협업 시스템 기술 설계 문서

## 1. 데이터베이스 스키마 설계 (PostgreSQL)

### 1.1 핵심 테이블 구조

#### users
```sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    nickname VARCHAR(100) NOT NULL,
    profile_image_url TEXT,
    is_admin BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_login_at TIMESTAMP,
    is_active BOOLEAN DEFAULT TRUE
);

CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
```

#### studios
```sql
CREATE TABLE studios (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_studios_user_id ON studios(user_id);
```

#### projects
```sql
CREATE TABLE projects (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    studio_id UUID NOT NULL REFERENCES studios(id) ON DELETE CASCADE,
    creator_id UUID NOT NULL REFERENCES users(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    deadline DATE,
    tag VARCHAR(50) CHECK (tag IN ('illustration', 'storyboard')),
    invite_code VARCHAR(20) UNIQUE,
    status VARCHAR(50) DEFAULT 'active' CHECK (status IN ('active', 'completed', 'archived')),
    has_updates BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_projects_studio_id ON projects(studio_id);
CREATE INDEX idx_projects_creator_id ON projects(creator_id);
CREATE INDEX idx_projects_invite_code ON projects(invite_code);
```

#### project_participants
```sql
CREATE TABLE project_participants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) DEFAULT 'member' CHECK (role IN ('owner', 'editor', 'viewer', 'member')),
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_viewed_at TIMESTAMP,
    UNIQUE(project_id, user_id)
);

CREATE INDEX idx_participants_project_id ON project_participants(project_id);
CREATE INDEX idx_participants_user_id ON project_participants(user_id);
```

#### scenes
```sql
CREATE TABLE scenes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    scene_number INTEGER NOT NULL,
    description TEXT,
    notes TEXT,
    created_by UUID NOT NULL REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(project_id, scene_number)
);

CREATE INDEX idx_scenes_project_id ON scenes(project_id);
```

#### images
```sql
CREATE TABLE images (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    scene_id UUID NOT NULL REFERENCES scenes(id) ON DELETE CASCADE,
    type VARCHAR(20) CHECK (type IN ('lineart', 'art')),
    file_url TEXT NOT NULL,
    file_size BIGINT,
    width INTEGER,
    height INTEGER,
    format VARCHAR(10) CHECK (format IN ('jpeg', 'png', 'webp')),
    is_current BOOLEAN DEFAULT TRUE,
    uploaded_by UUID NOT NULL REFERENCES users(id),
    uploaded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    metadata JSONB
);

CREATE INDEX idx_images_scene_id ON images(scene_id);
CREATE INDEX idx_images_type ON images(type);
CREATE INDEX idx_images_current ON images(scene_id, type, is_current);
```

#### image_history
```sql
CREATE TABLE image_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    image_id UUID NOT NULL REFERENCES images(id) ON DELETE CASCADE,
    scene_id UUID NOT NULL REFERENCES scenes(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_url TEXT NOT NULL,
    uploaded_by UUID NOT NULL REFERENCES users(id),
    uploaded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    change_description TEXT
);

CREATE INDEX idx_history_image_id ON image_history(image_id);
CREATE INDEX idx_history_scene_id ON image_history(scene_id);
```

#### comments
```sql
CREATE TABLE comments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    scene_id UUID REFERENCES scenes(id) ON DELETE CASCADE,
    parent_comment_id UUID REFERENCES comments(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id),
    content TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    is_edited BOOLEAN DEFAULT FALSE,
    is_deleted BOOLEAN DEFAULT FALSE,
    CHECK (project_id IS NOT NULL OR scene_id IS NOT NULL)
);

CREATE INDEX idx_comments_project_id ON comments(project_id);
CREATE INDEX idx_comments_scene_id ON comments(scene_id);
CREATE INDEX idx_comments_user_id ON comments(user_id);
```

#### annotations
```sql
CREATE TABLE annotations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    image_id UUID NOT NULL REFERENCES images(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id),
    type VARCHAR(50) CHECK (type IN ('drawing', 'text', 'arrow', 'rectangle')),
    position_x FLOAT NOT NULL,
    position_y FLOAT NOT NULL,
    width FLOAT,
    height FLOAT,
    content TEXT,
    drawing_data JSONB,
    color VARCHAR(7),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_annotations_image_id ON annotations(image_id);
```

#### user_presence
```sql
CREATE TABLE user_presence (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    scene_id UUID REFERENCES scenes(id) ON DELETE CASCADE,
    status VARCHAR(20) CHECK (status IN ('online', 'away', 'offline')),
    cursor_x FLOAT,
    cursor_y FLOAT,
    is_typing BOOLEAN DEFAULT FALSE,
    last_activity TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    socket_id VARCHAR(255),
    UNIQUE(user_id, project_id)
);

CREATE INDEX idx_presence_project_id ON user_presence(project_id);
CREATE INDEX idx_presence_status ON user_presence(status);
```

#### collaboration_logs
```sql
CREATE TABLE collaboration_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id),
    action_type VARCHAR(50) NOT NULL,
    target_type VARCHAR(50),
    target_id UUID,
    description TEXT,
    metadata JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_logs_project_id ON collaboration_logs(project_id);
CREATE INDEX idx_logs_user_id ON collaboration_logs(user_id);
CREATE INDEX idx_logs_created_at ON collaboration_logs(created_at DESC);
```

#### notifications
```sql
CREATE TABLE notifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    type VARCHAR(50) NOT NULL,
    title VARCHAR(255) NOT NULL,
    content TEXT,
    is_read BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    read_at TIMESTAMP
);

CREATE INDEX idx_notifications_user_id ON notifications(user_id, is_read);
```

---

## 2. WebSocket 이벤트 구조 설계

### 2.1 클라이언트 → 서버 이벤트

#### Connection Management
```javascript
// 연결 초기화
socket.emit('auth', {
    token: 'JWT_TOKEN',
    userId: 'USER_ID'
});

// 프로젝트 룸 참여
socket.emit('join:project', {
    projectId: 'PROJECT_ID',
    userId: 'USER_ID'
});

// 씬 룸 참여
socket.emit('join:scene', {
    projectId: 'PROJECT_ID',
    sceneId: 'SCENE_ID',
    userId: 'USER_ID'
});

// 룸 나가기
socket.emit('leave:project', {
    projectId: 'PROJECT_ID'
});
```

#### Presence Events
```javascript
// 커서 위치 업데이트
socket.emit('cursor:move', {
    projectId: 'PROJECT_ID',
    sceneId: 'SCENE_ID',
    x: 150,
    y: 200,
    userId: 'USER_ID'
});

// 타이핑 상태
socket.emit('typing:start', {
    projectId: 'PROJECT_ID',
    location: 'comment|annotation|description',
    targetId: 'TARGET_ID'
});

socket.emit('typing:stop', {
    projectId: 'PROJECT_ID',
    location: 'comment|annotation|description',
    targetId: 'TARGET_ID'
});

// 사용자 상태 변경
socket.emit('presence:update', {
    status: 'online|away|offline',
    projectId: 'PROJECT_ID'
});
```

#### Collaboration Events
```javascript
// 댓글 작성
socket.emit('comment:create', {
    projectId: 'PROJECT_ID',
    sceneId: 'SCENE_ID', // optional
    content: 'Comment text',
    parentId: null // for threads
});

// 댓글 수정
socket.emit('comment:update', {
    commentId: 'COMMENT_ID',
    content: 'Updated text'
});

// 댓글 삭제
socket.emit('comment:delete', {
    commentId: 'COMMENT_ID'
});

// 주석 추가
socket.emit('annotation:create', {
    imageId: 'IMAGE_ID',
    type: 'drawing|text|arrow',
    data: {
        x: 100,
        y: 150,
        content: 'Annotation content',
        drawingData: {} // for drawing type
    }
});

// 주석 수정
socket.emit('annotation:update', {
    annotationId: 'ANNOTATION_ID',
    data: {
        content: 'Updated content'
    }
});

// 이미지 업로드 알림
socket.emit('image:upload', {
    sceneId: 'SCENE_ID',
    type: 'lineart|art',
    imageId: 'IMAGE_ID',
    metadata: {
        fileName: 'image.png',
        fileSize: 1024000
    }
});

// 씬 업데이트
socket.emit('scene:update', {
    sceneId: 'SCENE_ID',
    data: {
        description: 'Updated description',
        notes: 'Updated notes'
    }
});
```

### 2.2 서버 → 클라이언트 이벤트

#### Connection Events
```javascript
// 연결 성공
socket.on('connected', {
    userId: 'USER_ID',
    socketId: 'SOCKET_ID'
});

// 인증 성공
socket.on('authenticated', {
    user: { id, username, nickname }
});

// 룸 참여 성공
socket.on('joined:project', {
    projectId: 'PROJECT_ID',
    participants: [...] // 현재 온라인 사용자 목록
});
```

#### Broadcast Events
```javascript
// 새 사용자 참여
socket.on('user:joined', {
    user: { id, username, nickname, profileImage },
    projectId: 'PROJECT_ID'
});

// 사용자 나감
socket.on('user:left', {
    userId: 'USER_ID',
    projectId: 'PROJECT_ID'
});

// 커서 위치 브로드캐스트
socket.on('cursor:moved', {
    userId: 'USER_ID',
    x: 150,
    y: 200,
    userName: 'User Name'
});

// 타이핑 상태 브로드캐스트
socket.on('typing:status', {
    userId: 'USER_ID',
    userName: 'User Name',
    isTyping: true,
    location: 'comment'
});

// 새 댓글 브로드캐스트
socket.on('comment:created', {
    comment: {
        id: 'COMMENT_ID',
        content: 'Comment text',
        user: { id, username, nickname },
        createdAt: '2024-01-01T00:00:00Z'
    }
});

// 댓글 업데이트 브로드캐스트
socket.on('comment:updated', {
    commentId: 'COMMENT_ID',
    content: 'Updated text',
    updatedAt: '2024-01-01T00:00:00Z'
});

// 댓글 삭제 브로드캐스트
socket.on('comment:deleted', {
    commentId: 'COMMENT_ID'
});

// 새 주석 브로드캐스트
socket.on('annotation:created', {
    annotation: {
        id: 'ANNOTATION_ID',
        imageId: 'IMAGE_ID',
        type: 'drawing',
        data: {...},
        user: { id, username }
    }
});

// 이미지 업로드 브로드캐스트
socket.on('image:uploaded', {
    sceneId: 'SCENE_ID',
    image: {
        id: 'IMAGE_ID',
        type: 'lineart',
        url: 'https://...',
        uploadedBy: { id, username }
    }
});

// 씬 업데이트 브로드캐스트
socket.on('scene:updated', {
    sceneId: 'SCENE_ID',
    updates: {
        description: '...',
        updatedBy: { id, username }
    }
});

// 프로젝트 알림
socket.on('project:notification', {
    type: 'update|deadline|new_member',
    message: 'Notification message',
    projectId: 'PROJECT_ID'
});
```

#### Error Events
```javascript
// 에러 처리
socket.on('error', {
    code: 'ERROR_CODE',
    message: 'Error message',
    details: {}
});

// 재연결 필요
socket.on('reconnect:required', {
    reason: 'Session expired'
});
```

---

## 3. API + WebSocket 통합 아키텍처

### 3.1 기술 스택

```yaml
Backend:
  Framework: Next.js 14+ (App Router)
  Language: TypeScript
  Database: PostgreSQL (Railway)
  ORM: Prisma
  WebSocket: Socket.io
  Authentication: NextAuth.js + JWT
  Validation: Zod
  File Upload: Multer + Sharp (이미지 처리)
  Storage: Railway Volumes / AWS S3 (선택적)
  
Frontend:
  Framework: Next.js 14+ (RSC + Client Components)
  State Management: Zustand
  WebSocket Client: Socket.io-client
  UI Library: Tailwind CSS + shadcn/ui
  Image Viewer: react-zoom-pan-pinch
  Drawing: Konva.js / Fabric.js
  Forms: React Hook Form + Zod
  
DevOps:
  Deployment: Railway
  CI/CD: GitHub Actions
  Monitoring: Railway Metrics
  Logging: Winston / Pino
```

### 3.2 API 엔드포인트 구조

#### Authentication APIs
```
POST   /api/auth/register     - 회원가입
POST   /api/auth/login        - 로그인
POST   /api/auth/logout       - 로그아웃
POST   /api/auth/refresh      - 토큰 갱신
GET    /api/auth/session      - 세션 확인
```

#### User APIs
```
GET    /api/users/profile          - 프로필 조회
PUT    /api/users/profile          - 프로필 수정
POST   /api/users/profile/image    - 프로필 이미지 업로드
DELETE /api/users/profile/image    - 프로필 이미지 삭제
```

#### Studio APIs
```
GET    /api/studios              - 내 스튜디오 조회
GET    /api/studios/:id          - 스튜디오 상세
PUT    /api/studios/:id          - 스튜디오 수정
```

#### Project APIs
```
GET    /api/projects                     - 프로젝트 목록
POST   /api/projects                     - 프로젝트 생성
GET    /api/projects/:id                 - 프로젝트 상세
PUT    /api/projects/:id                 - 프로젝트 수정
DELETE /api/projects/:id                 - 프로젝트 삭제
POST   /api/projects/:id/invite          - 초대 코드 생성
POST   /api/projects/join                - 초대 코드로 참여
GET    /api/projects/:id/participants    - 참여자 목록
DELETE /api/projects/:id/participants/:userId - 참여자 제거
```

#### Scene APIs
```
GET    /api/projects/:projectId/scenes           - 씬 목록
POST   /api/projects/:projectId/scenes           - 씬 생성
GET    /api/projects/:projectId/scenes/:id       - 씬 상세
PUT    /api/projects/:projectId/scenes/:id       - 씬 수정
DELETE /api/projects/:projectId/scenes/:id       - 씬 삭제
```

#### Image APIs
```
POST   /api/scenes/:sceneId/images              - 이미지 업로드
GET    /api/scenes/:sceneId/images              - 이미지 목록
GET    /api/scenes/:sceneId/images/:id          - 이미지 상세
DELETE /api/scenes/:sceneId/images/:id          - 이미지 삭제
GET    /api/scenes/:sceneId/images/:id/history  - 이미지 히스토리
POST   /api/scenes/:sceneId/images/:id/restore  - 이전 버전 복원
```

#### Comment APIs
```
GET    /api/projects/:projectId/comments         - 프로젝트 댓글 목록
POST   /api/projects/:projectId/comments         - 프로젝트 댓글 작성
GET    /api/scenes/:sceneId/comments            - 씬 댓글 목록
POST   /api/scenes/:sceneId/comments            - 씬 댓글 작성
PUT    /api/comments/:id                        - 댓글 수정
DELETE /api/comments/:id                        - 댓글 삭제
```

#### Annotation APIs
```
GET    /api/images/:imageId/annotations      - 주석 목록
POST   /api/images/:imageId/annotations      - 주석 생성
PUT    /api/annotations/:id                  - 주석 수정
DELETE /api/annotations/:id                  - 주석 삭제
```

#### Admin APIs
```
GET    /api/admin/users                - 전체 사용자 목록
GET    /api/admin/projects             - 전체 프로젝트 목록
DELETE /api/admin/projects/:id         - 프로젝트 강제 삭제
GET    /api/admin/stats                - 시스템 통계
```

### 3.3 WebSocket + API 통합 패턴

#### 1. Hybrid Operations Pattern
```typescript
// 예시: 댓글 작성 플로우
// 1. API로 댓글 저장
const response = await fetch('/api/comments', {
    method: 'POST',
    body: JSON.stringify({ content, projectId })
});
const comment = await response.json();

// 2. WebSocket으로 실시간 브로드캐스트
socket.emit('comment:created', comment);

// 3. 다른 클라이언트에서 수신
socket.on('comment:created', (comment) => {
    // UI 업데이트
    addCommentToUI(comment);
});
```

#### 2. Optimistic Updates Pattern
```typescript
// 클라이언트에서 즉시 UI 업데이트
const optimisticComment = {
    id: 'temp-' + Date.now(),
    content: commentText,
    user: currentUser,
    createdAt: new Date()
};

// 1. 낙관적 업데이트
addCommentToUI(optimisticComment);

// 2. 서버 요청
try {
    const actualComment = await createComment(commentText);
    // 3. 실제 데이터로 교체
    replaceOptimisticComment(optimisticComment.id, actualComment);
    // 4. WebSocket 브로드캐스트
    socket.emit('comment:created', actualComment);
} catch (error) {
    // 5. 실패 시 롤백
    removeComment(optimisticComment.id);
    showError('댓글 작성 실패');
}
```

#### 3. Presence Management Pattern
```typescript
// 서버 측 프레젠스 관리
class PresenceManager {
    private presenceData = new Map();
    
    async updatePresence(userId: string, data: PresenceData) {
        // 1. 메모리에 저장 (빠른 액세스)
        this.presenceData.set(userId, data);
        
        // 2. DB에 주기적으로 저장 (영속성)
        await this.batchUpdateDB();
        
        // 3. 브로드캐스트
        io.to(data.projectId).emit('presence:update', {
            userId,
            ...data
        });
    }
    
    // 5초마다 DB 업데이트
    private async batchUpdateDB() {
        // Batch update logic
    }
}
```

#### 4. File Upload with Progress Pattern
```typescript
// 클라이언트
const uploadImage = async (file: File, sceneId: string) => {
    const formData = new FormData();
    formData.append('image', file);
    
    // XMLHttpRequest for progress tracking
    const xhr = new XMLHttpRequest();
    
    xhr.upload.onprogress = (e) => {
        const progress = (e.loaded / e.total) * 100;
        // WebSocket으로 진행률 브로드캐스트
        socket.emit('upload:progress', {
            sceneId,
            progress,
            fileName: file.name
        });
    };
    
    xhr.onload = () => {
        const image = JSON.parse(xhr.responseText);
        // 업로드 완료 브로드캐스트
        socket.emit('image:uploaded', {
            sceneId,
            image
        });
    };
    
    xhr.open('POST', `/api/scenes/${sceneId}/images`);
    xhr.send(formData);
};
```

### 3.4 보안 및 인증 통합

#### JWT + WebSocket Authentication
```typescript
// 서버 측 Socket.io 미들웨어
io.use(async (socket, next) => {
    try {
        const token = socket.handshake.auth.token;
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        
        // 사용자 정보 조회
        const user = await prisma.user.findUnique({
            where: { id: decoded.userId }
        });
        
        if (!user) {
            return next(new Error('User not found'));
        }
        
        // Socket에 사용자 정보 저장
        socket.data.user = user;
        next();
    } catch (err) {
        next(new Error('Authentication failed'));
    }
});

// 프로젝트 권한 검증
const checkProjectAccess = async (socket, projectId) => {
    const participant = await prisma.projectParticipants.findFirst({
        where: {
            projectId,
            userId: socket.data.user.id
        }
    });
    
    return participant !== null;
};
```

### 3.5 성능 최적화 전략

#### 1. Connection Pooling
```typescript
// PostgreSQL 연결 풀 설정
const prisma = new PrismaClient({
    datasources: {
        db: {
            url: process.env.DATABASE_URL,
        },
    },
    log: ['error', 'warn'],
    connectionLimit: 10, // Railway 제한 고려
});
```

#### 2. Redis for Session & Cache (선택적)
```typescript
// Redis 캐싱 레이어
import Redis from 'ioredis';

const redis = new Redis(process.env.REDIS_URL);

// 프레젠스 데이터 캐싱
await redis.setex(
    `presence:${userId}`,
    30, // 30초 TTL
    JSON.stringify(presenceData)
);

// Socket.io Redis Adapter
import { createAdapter } from '@socket.io/redis-adapter';
io.adapter(createAdapter(pubClient, subClient));
```

#### 3. Image Optimization
```typescript
// Sharp를 사용한 이미지 최적화
import sharp from 'sharp';

const optimizeImage = async (buffer: Buffer) => {
    const optimized = await sharp(buffer)
        .resize(1920, 1080, { 
            fit: 'inside',
            withoutEnlargement: true 
        })
        .webp({ quality: 85 })
        .toBuffer();
    
    return optimized;
};
```

### 3.6 에러 처리 및 복구

#### Graceful Degradation
```typescript
// WebSocket 연결 실패 시 폴백
class RealtimeManager {
    private socket: Socket | null = null;
    private fallbackMode = false;
    
    connect() {
        try {
            this.socket = io(SOCKET_URL);
            this.setupEventHandlers();
        } catch (error) {
            console.error('WebSocket connection failed');
            this.enableFallbackMode();
        }
    }
    
    private enableFallbackMode() {
        this.fallbackMode = true;
        // Polling으로 전환
        this.startPolling();
    }
    
    private startPolling() {
        setInterval(async () => {
            const updates = await fetch('/api/updates');
            this.processUpdates(await updates.json());
        }, 5000); // 5초마다 폴링
    }
}
```

#### Auto-reconnection Strategy
```typescript
// 클라이언트 자동 재연결
const socket = io(SOCKET_URL, {
    reconnection: true,
    reconnectionDelay: 1000,
    reconnectionDelayMax: 5000,
    reconnectionAttempts: 10,
    transports: ['websocket', 'polling'] // 폴백 지원
});

socket.on('connect', () => {
    console.log('Connected');
    // 상태 복구
    restorePresence();
    rejoinRooms();
});

socket.on('disconnect', (reason) => {
    console.log('Disconnected:', reason);
    if (reason === 'io server disconnect') {
        // 서버가 연결을 끊은 경우 수동 재연결
        socket.connect();
    }
});
```

---

## 4. 배포 구성 (Railway)

### 4.1 환경 변수 설정
```env
# Database
DATABASE_URL=postgresql://user:password@host:5432/dbname

# Auth
NEXTAUTH_URL=https://your-app.railway.app
NEXTAUTH_SECRET=your-secret-key
JWT_SECRET=your-jwt-secret

# Storage
STORAGE_TYPE=local # or 's3'
UPLOAD_DIR=/app/uploads

# WebSocket
SOCKET_PORT=3001
SOCKET_PATH=/socket.io

# Redis (Optional)
REDIS_URL=redis://...

# Admin
ADMIN_EMAIL=admin@example.com
```

### 4.2 Railway 배포 설정
```json
{
    "build": {
        "builder": "NIXPACKS",
        "buildCommand": "npm run build"
    },
    "deploy": {
        "startCommand": "npm run start",
        "healthcheckPath": "/api/health",
        "restartPolicyType": "ON_FAILURE",
        "restartPolicyMaxRetries": 3
    },
    "services": [
        {
            "name": "web",
            "port": 3000
        },
        {
            "name": "websocket",
            "port": 3001
        }
    ]
}
```

### 4.3 데이터베이스 마이그레이션
```bash
# Prisma 마이그레이션
npx prisma generate
npx prisma migrate deploy

# 초기 데이터 시딩
npx prisma db seed
```

---

## 5. 모니터링 및 로깅

### 5.1 로깅 전략
```typescript
import winston from 'winston';

const logger = winston.createLogger({
    level: process.env.LOG_LEVEL || 'info',
    format: winston.format.json(),
    transports: [
        new winston.transports.File({ 
            filename: 'error.log', 
            level: 'error' 
        }),
        new winston.transports.File({ 
            filename: 'combined.log' 
        }),
        new winston.transports.Console({
            format: winston.format.simple()
        })
    ]
});

// WebSocket 이벤트 로깅
io.on('connection', (socket) => {
    logger.info('New connection', {
        socketId: socket.id,
        userId: socket.data.user?.id
    });
});
```

### 5.2 성능 모니터링
```typescript
// 커스텀 메트릭 수집
class MetricsCollector {
    private metrics = {
        activeConnections: 0,
        messagesPerSecond: 0,
        averageResponseTime: 0
    };
    
    collectMetrics() {
        // Railway 메트릭 API로 전송
        setInterval(() => {
            this.sendToRailway(this.metrics);
        }, 60000); // 1분마다
    }
}
```

---

## 6. 추후 확장 고려사항

### 6.1 Nano Banana AI 통합 준비
```typescript
// AI 이미지 생성을 위한 인터페이스 준비
interface AIImageGenerationRequest {
    sceneId: string;
    prompt: string;
    referenceImages?: string[];
    style?: 'illustration' | 'storyboard';
}

// API 엔드포인트 예약
// POST /api/ai/generate-image
// POST /api/ai/generate-scene
// POST /api/ai/generate-project
```

### 6.2 스케일링 전략
- Horizontal Pod Autoscaling 준비
- Database Read Replicas 구성
- CDN 통합 (이미지 서빙)
- Queue System (Bull/BullMQ) 도입
- Microservices 아키텍처 전환 준비